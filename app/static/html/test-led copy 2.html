<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>VLC OOK Decoder (4Hz)</title>
<style>
  :root{font-family:system-ui,Segoe UI,Roboto,Noto Sans,Arial,sans-serif}
  body{margin:0;padding:16px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  video,canvas{max-width:100%;border:1px solid #ddd;border-radius:12px}
  button,input{padding:10px 14px;border-radius:10px;border:1px solid #ccc;background:#fff}
  #log{white-space:pre-wrap;background:#f7f7f7;border:1px solid #eee;border-radius:8px;padding:8px;min-height:6em}
  .hud{position:relative;display:inline-block}
  .roi{position:absolute;border:2px dashed #06c;inset:calc(50% - 50px) calc(50% - 50px) auto auto;width:100px;height:100px;pointer-events:none}
  small{color:#666}
</style>
</head>
<body>
<h2>可見光編碼 OOK 解碼（4 Hz 專用）</h2>

<div class="row">
  <label>位元率 (Hz)：<input type="number" id="bitHz" value="4" min="1" max="15" step="1"></label>
  <label>ROI 邊長(px)：<input type="number" id="roi" value="100" min="20" max="240"></label>
  <label>Payload 位數：<input type="number" id="payloadBits" value="8" min="1" max="64"></label>
  <button id="startBtn">啟動相機</button>
  <button id="stopBtn" disabled>停止</button>
  <button id="torchBtn" disabled>手電筒</button>
</div>
<small>請使用 HTTPS 或 http://localhost；避免在 App 內嵌瀏覽器開啟（如 LINE/IG）。</small>

<div class="row" style="margin-top:12px">
  <div class="hud">
    <video id="v" playsinline muted></video>
    <div class="roi" id="roiBox"></div>
  </div>
  <canvas id="c" width="320" height="240" hidden></canvas>
</div>

<h3>狀態</h3>
<div id="log">尚未開始</div>

<script>
const v = document.getElementById('v');
const c = document.getElementById('c');
const ctx = c.getContext('2d', { willReadFrequently: true });
const logEl = document.getElementById('log');
const bitHzEl = document.getElementById('bitHz');
const roiEl = document.getElementById('roi');
const payloadBitsEl = document.getElementById('payloadBits');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const torchBtn = document.getElementById('torchBtn');

let stream, track;
let running = false;
let sampleTimer = null;
let imageCapture = null;

// 信號緩衝（最近 3 秒亮度）
const lumBuf = [];
const timeBuf = [];
const MAX_SEC = 3.0;

// OOK 設定
let bitHz = 4;
let bitSec = 0.25; // 1/4Hz
const PREAMBLE = "10101010";

function log(msg){
  logEl.textContent = msg;
}

function pushSample(t, y){
  lumBuf.push(y);
  timeBuf.push(t);
  // 丟掉超過 MAX_SEC 的舊資料
  while (timeBuf.length && (timeBuf[timeBuf.length-1] - timeBuf[0] > MAX_SEC)) {
    lumBuf.shift(); timeBuf.shift();
  }
}

function median(arr){
  if (!arr.length) return 0;
  const a = arr.slice().sort((x,y)=>x-y);
  const m = Math.floor(a.length/2);
  return a.length%2 ? a[m] : (a[m-1]+a[m])/2;
}

// 讀取 ROI 平均亮度
function readROILuma(){
  if (!v.videoWidth || !v.videoHeight) return null;
  const W = c.width = v.videoWidth;
  const H = c.height = v.videoHeight;
  ctx.drawImage(v, 0, 0, W, H);

  const side = Math.min(Number(roiEl.value)||100, Math.min(W,H));
  const x0 = (W - side) >> 1;
  const y0 = (H - side) >> 1;
  const data = ctx.getImageData(x0, y0, side, side).data;

  let sum=0;
  for (let i=0;i<data.length;i+=4){
    // Y ≈ 0.2126R + 0.7152G + 0.0722B
    sum += 0.2126*data[i] + 0.7152*data[i+1] + 0.0722*data[i+2];
  }
  return sum/(side*side);
}

// OOK：每個 bit 取一次樣，轉 0/1（自適應門檻 + Hysteresis）
function decodeOOK(bits){
  // 找前導碼後取 payload
  const s = bits.join('');
  const idx = s.indexOf(PREAMBLE);
  const payloadLen = Number(payloadBitsEl.value || 8);
  if (idx === -1) return null;
  if (idx + PREAMBLE.length + payloadLen > bits.length) return null;
  return s.slice(idx + PREAMBLE.length, idx + PREAMBLE.length + payloadLen);
}

async function start(){
  // 基本環境檢查
  if (!('mediaDevices' in navigator) || !('getUserMedia' in navigator.mediaDevices)) {
    alert('此環境不支援相機：請使用 HTTPS（或 http://localhost），並用 Chrome/Firefox 開啟。');
    return;
  }
  if (!isSecureContext && location.hostname !== 'localhost') {
    alert('需在 HTTPS 或 http://localhost 下開啟才能使用相機。');
    return;
  }

  bitHz = Number(bitHzEl.value || 4);
  bitSec = 1 / bitHz;

  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: 'environment' },
        frameRate: { ideal: 60, max: 60 },
        width: { ideal: 1280 }, height: { ideal: 720 }
      },
      audio: false
    });
  } catch (e) {
    console.error(e);
    alert('開啟相機失敗：' + e.name + '\n請確認權限與瀏覽器/HTTPS。');
    return;
  }

  v.srcObject = stream;
  await v.play();
  track = stream.getVideoTracks()[0];
  try {
    imageCapture = new ImageCapture(track);
    const caps = track.getCapabilities?.();
    if (caps && 'torch' in caps) torchBtn.disabled = false;
  } catch { torchBtn.disabled = true; }

  running = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  torchBtn.disabled = torchBtn.disabled || false;

  log(`相機啟動中… OOK ${bitHz} Hz。\n把 LED 放在 ROI 方框內。等待前導碼 ${PREAMBLE}。`);

  // 視訊幀迴圈：高頻取樣亮度 → 緩衝
  const pump = (now, meta) => {
    if (!running) return;
    const y = readROILuma();
    if (y != null) pushSample(performance.now()/1000, y);
    v.requestVideoFrameCallback(pump);
  };
  if ('requestVideoFrameCallback' in HTMLVideoElement.prototype){
    v.requestVideoFrameCallback(pump);
  } else {
    (function loop(){
      if (!running) return;
      const y = readROILuma();
      if (y != null) pushSample(performance.now()/1000, y);
      requestAnimationFrame(loop);
    })();
  }

  // 位元時脈：每 bitSec 取一次（例如 0.25s）
  let schmittState = 0; // 0=暗,1=亮
  let bitsWindow = [];
  let lastSampleT = performance.now()/1000;
  const HYS = 0.10; // 門檻相對振幅 10% 當作舒密特帶

  sampleTimer = setInterval(()=>{
    if (!running || timeBuf.length < 10) return;

    // 自適應門檻：最近 1.5 秒
    const now = performance.now()/1000;
    const recent = [];
    for (let i=timeBuf.length-1;i>=0;i--){
      if (now - timeBuf[i] <= 1.5) recent.push(lumBuf[i]); else break;
    }
    if (recent.length < 10) return;

    const lo = Math.min(...recent);
    const hi = Math.max(...recent);
    const mid = (lo + hi)/2;
    const amp = Math.max(hi - lo, 1);

    // 舒密特上下限
    const lowTh  = mid - amp*HYS*0.5;
    const highTh = mid + amp*HYS*0.5;

    // 取目前亮度（最近值）
    const y = lumBuf[lumBuf.length-1];

    // Schmitt trigger：降低抖動
    if (schmittState === 0 && y > highTh) schmittState = 1;
    else if (schmittState === 1 && y < lowTh) schmittState = 0;

    bitsWindow.push(schmittState);

    // 對齊 bit 邏輯：固定每次只收 1 個樣本（此處用 setInterval 本身的節拍）
    // 這裡我們已經每 1/bitHz 秒跑一次，不需要額外合併
    // 但為了兼容 timer 抖動，保留單一樣本策略即可

    // 視窗過長時嘗試解碼
    if (bitsWindow.length >= PREAMBLE.length + Number(payloadBitsEl.value || 8) + 2) {
      const payload = decodeOOK(bitsWindow);
      if (payload) {
        const val10 = parseInt(payload, 2);
        log(
          `解碼成功！\n` +
          `前導碼=${PREAMBLE}\n` +
          `payload(bits)=${payload}\n` +
          `payload(dec)=${isNaN(val10)?'N/A':val10}\n` +
          `位元率≈${bitHz} Hz（設定）`
        );
        // 清掉已使用的前段，避免重複觸發
        const drop = bitsWindow.join('').indexOf(PREAMBLE) + PREAMBLE.length + payload.length;
        bitsWindow = bitsWindow.slice(drop);
      } else {
        // 避免無止境增長
        if (bitsWindow.length > 400) bitsWindow = bitsWindow.slice(-200);
      }
    }
  }, Math.round(bitSec*1000)); // 250ms for 4Hz
}

function stop(){
  running = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  torchBtn.disabled = true;
  if (sampleTimer){ clearInterval(sampleTimer); sampleTimer = null; }
  if (stream){
    stream.getTracks().forEach(t=>t.stop());
    stream = null; track=null; imageCapture=null;
  }
  log('已停止。');
}

torchBtn.addEventListener('click', async ()=>{
  if (!track) return;
  try {
    const caps = track.getCapabilities?.();
    if (caps && 'torch' in caps) {
      const cur = track.getSettings?.().torch;
      await track.applyConstraints({ advanced: [{ torch: !cur }]});
    }
  } catch(e){ console.warn(e); }
});

startBtn.addEventListener('click', start);
stopBtn.addEventListener('click', stop);
</script>
</body>
</html>

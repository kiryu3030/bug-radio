<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>VLC Demo (No OpenCV)</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Noto Sans,Arial,sans-serif;margin:0;padding:12px}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  video,canvas{max-width:100%;border:1px solid #ddd;border-radius:12px}
  #log{white-space:pre-wrap;background:#f7f7f7;border:1px solid #eee;border-radius:8px;padding:8px;min-height:4em}
  .hud{position:relative;display:inline-block}
  .roi{position:absolute;border:2px dashed #00a;inset:calc(50% - 50px) calc(50% - 50px) auto auto;width:100px;height:100px;pointer-events:none}
  button{padding:10px 14px;border-radius:10px;border:1px solid #ccc;background:#fff;cursor:pointer}
  label{display:inline-flex;align-items:center;gap:8px}
</style>
</head>
<body>
<h2>可見光編碼（曼徹斯特）相機解碼 Demo</h2>

<div class="row">
  <label>目標位元率(估)：<input type="number" id="bitHz" value="4" min="2" max="60"> Hz</label>
  <label>ROI 邊長：<input type="number" id="roi" value="100" min="20" max="240"> px</label>
  <button id="startBtn">啟動相機</button>
  <button id="torchBtn" disabled>開/關手電筒*</button>
</div>
<small>* 部分瀏覽器/裝置支援透過 ImageCapture 控制。</small>

<div class="row">
  <div class="hud">
    <video id="v" playsinline muted></video>
    <div class="roi" id="roiBox"></div>
  </div>
  <canvas id="c" width="320" height="240" hidden></canvas>
</div>

<h3>狀態</h3>
<div id="log">尚未開始</div>

<script>
const v = document.getElementById('v');
const c = document.getElementById('c');
const g = c.getContext('2d', { willReadFrequently: true });
const log = (m)=>{ document.getElementById('log').textContent = m; };
const bitHzEl = document.getElementById('bitHz');
const roiEl = document.getElementById('roi');
const roiBox = document.getElementById('roiBox');
const startBtn = document.getElementById('startBtn');
const torchBtn = document.getElementById('torchBtn');

let stream, imageCapture, track;
let running = false;
let tsLast = 0;

// 簡單訊號處理緩衝
const buf = [];
const MAX_BUF = 4096;

// 參數
let targetBitHz = 4;      // 位元率（曼徹斯特半位寬 = 1/(2*bitHz)）
let Tb = 1 / targetBitHz;  // 一個 bit 的秒數
let halfTb = Tb / 2;

function median(arr){
  const a = arr.slice().sort((x,y)=>x-y);
  const m = Math.floor(a.length/2);
  return a.length%2 ? a[m] : (a[m-1]+a[m])/2;
}

function movingAvg(arr, w){
  let s = 0;
  for (let i=Math.max(0,arr.length-w); i<arr.length; i++) s += arr[i];
  return s / Math.min(w, arr.length);
}

async function start(){
  targetBitHz = Number(bitHzEl.value || 20);
  Tb = 1/targetBitHz;
  halfTb = Tb/2;

  stream = await navigator.mediaDevices.getUserMedia({
    video: {
      facingMode: { ideal: "environment" },
      frameRate: { ideal: 60, max: 60 },  // 盡量高一些
      width: { ideal: 1280 }, height: { ideal: 720 },
      advanced: [{ focusMode: "continuous" }]
    },
    audio: false
  });
  v.srcObject = stream;
  track = stream.getVideoTracks()[0];

  // 嘗試 ImageCapture（用於手電筒/曝光控制）
  try {
    imageCapture = new ImageCapture(track);
    torchBtn.disabled = false;
  } catch { torchBtn.disabled = true; }

  await v.play();
  running = true;
  log("相機啟動中… 對準發光體（LED/燈），把它放在 ROI 中央。");

  // 用 requestVideoFrameCallback（回退用 rAF）
  const pump = (now, metadata) => {
    if (!running) return;
    drawAndSample(now/1000); // 秒
    v.requestVideoFrameCallback(pump);
  };
  if ('requestVideoFrameCallback' in HTMLVideoElement.prototype){
    console.log('Frame');
    v.requestVideoFrameCallback(pump);
  } else {
    console.log('loop');
    const loop = (t)=>{ if (running){ drawAndSample(performance.now()/1000); requestAnimationFrame(loop); } };
    requestAnimationFrame(loop);
  }
}

function drawAndSample(tNow){
  // 將 video 畫到 canvas
  const W = c.width = v.videoWidth ? v.videoWidth : 320;
  const H = c.height = v.videoHeight ? v.videoHeight : 240;
  g.drawImage(v, 0, 0, W, H);

  // ROI
  const side = Math.min(Number(roiEl.value)||100, Math.min(W,H));
  const x0 = (W - side) >> 1;
  const y0 = (H - side) >> 1;
  const img = g.getImageData(x0, y0, side, side).data;

  // 平均亮度（簡單 Y = 0.2126R + 0.7152G + 0.0722B）
  let sum = 0;
  for (let i=0; i<img.length; i+=4){
    const r=img[i], g1=img[i+1], b=img[i+2];
    sum += 0.2126*r + 0.7152*g1 + 0.0722*b;
  }
  const lum = sum / (side*side);

  // 低通 IIR
  const alpha = 0.2; // 平滑係數（可調）
  const last = buf.length ? buf[buf.length-1].y : lum;
  const smooth = last + alpha*(lum - last);

  // 存 (t, y)
  buf.push({ t: tNow, y: smooth });
  if (buf.length > MAX_BUF) buf.shift();

  // 嘗試解碼
  const msg = tryDecodeManchester(buf);
  if (msg) {
    log(`解碼成功：${msg.payloadBits}（十進位=${parseInt(msg.payloadBits,2)}）\n位元寬估計=${(msg.bitSec).toFixed(4)}s @ ${(1/msg.bitSec).toFixed(1)}Hz\nSNR-ish=${msg.snr.toFixed(2)}`);
  }
}

function tryDecodeManchester(b){
  if (b.length < 60) {
    console.log("1111")
    return null;
  }

  // 自適應門檻：最近 1~2 秒資料
  const tail = b.filter(p => b[b.length-1].t - p.t < 2.0).map(p => p.y);
  if (tail.length < 30) {
    console.log("222222")
    return null;
  }
  const th = median(tail); // 門檻
  const hi = movingAvg(tail.filter(v=>v>th), Math.min(20, tail.length)) || (th+10);
  const lo = movingAvg(tail.filter(v=>v<th), Math.min(20, tail.length)) || (th-10);
  const amp = Math.max(1, hi - lo);
  const snr = amp / (Math.max(1, movingAvg(tail.map(v=>Math.abs(v - (v>th?hi:lo))), 30)));

  // 產生符號化序列（>th -> 1, 否則 0）
  const sym = b.map(p => ({ t:p.t, s: (p.y>th)?1:0 }));

  // 找零交越，估 halfTb
  const edges = [];
  for (let i=1;i<sym.length;i++){
    if (sym[i].s !== sym[i-1].s){
      // 線性插值交越時間
      const t = sym[i].t; // 近似
      edges.push(t);
    }
  }
  if (edges.length < 8) {
    console.log("33333")
    return null;
  }

  // 估半位寬：用最後一段邊緣間隔的中位數
  const intervals = [];
  for (let i=1;i<edges.length;i++) intervals.push(edges[i]-edges[i-1]);
  const halfTbEst = median(intervals);
  const bitSec = halfTbEst*2;

  // 以最後一個 edge 當作相位基準，向後等距取樣（每 halfTb 取一次）
  const start = edges[edges.length-1] + halfTbEst*0.5;
  const endTime = sym[sym.length-1].t;
  const samples = [];
  for (let t=start; t<endTime; t+=halfTbEst){
    // 取最接近時間點的 s
    let lo=0, hi2=sym.length-1;
    while (lo<hi2){
      const mid=(lo+hi2)>>1;
      if (sym[mid].t < t) lo=mid+1; else hi2=mid;
    }
    const idx = Math.max(0, Math.min(sym.length-1, lo));
    samples.push(sym[idx].s);
  }
  if (samples.length < 24) {
    console.log("44444")
    return null;
  }

  // 將每兩個 halfTb 合成一個位元（曼徹斯特：10->1, 01->0）
  // 尋找前導碼 10101010（8 bits）
  const bits = [];
  for (let i=0; i+1<samples.length; i+=2){
    const a=samples[i], b2=samples[i+1];
    if (a===1 && b2===0) bits.push(1);
    else if (a===0 && b2===1) bits.push(0);
    else bits.push(null); // 異常（可能相位錯）
  }

  // 尋找連續 10101010
  const preamble = [1,0,1,0,1,0,1,0].join('');
  const bitStr = bits.map(b => (b==null?'x':b)).join('');
  const idx = bitStr.indexOf(preamble);
  if (idx === -1 || idx + 8 + 8 > bits.length) {
    console.log("55555")
    return null;
  }

  // 取前導碼後的 8 位 payload
  const payload = bits.slice(idx+8, idx+16);
  if (payload.some(b=>b==null)) {
    console.log("6666")
    return null;
  }

  return {
    payloadBits: payload.join(''),
    bitSec,
    snr
  };
}

// Torch 切換（若支援）
torchBtn.addEventListener('click', async()=>{
  if (!track) return;
  try {
    const caps = track.getCapabilities?.();
    if (caps && 'torch' in caps) {
      const settings = track.getSettings?.() || {};
      const enable = !settings.torch;
      await track.applyConstraints({ advanced: [{ torch: enable }]});
    }
  } catch (e) {
    console.warn(e);
  }
});

startBtn.addEventListener('click', ()=>{
  if (!running) start();
});
</script>
</body>
</html>

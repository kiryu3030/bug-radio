<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VLC Manchester 解碼（2 Hz / 8-bit）</title>
<style>
  :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, sans-serif; }
  body { max-width: 960px; margin: 24px auto; padding: 0 16px; }
  .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
  video, canvas { max-width: 100%; border-radius: 12px; }
  .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 12px; }
  label { font-size: 14px; color:#374151; }
  input, select, button { padding: 8px 10px; border-radius: 10px; border:1px solid #cbd5e1; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  #overlay { position:absolute; inset:0; pointer-events:none; }
  .stack { display:grid; }
  small { color:#6b7280; }
</style>
</head>
<body>
<h1>可見光 Manchester 解碼（Web, 2 Hz / 8-bit）</h1>

<div class="card">
  <div class="row">
    <label>鏡頭：</label>
    <select id="camera"></select>
    <label>符元率 (Hz)：</label>
    <input id="symRate" type="number" min="0.1" step="0.1" value="2">
    <label><input id="autoRate" type="checkbox"> 自動估計符元期</label>
    <button id="start">啟動相機</button>
    <button id="stop" disabled>停止</button>
  </div>
  <div class="row" style="margin-top:8px;">
    <small>提示：HTTPS 或 localhost 才能取用相機。點影片「拖拉方框」選 ROI（取樣區）。</small>
  </div>
</div>

<div class="row" style="margin-top:16px;">
  <div class="stack" style="position:relative;flex:1;min-width:280px;">
    <video id="video" playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>
  <canvas id="canvas" class="card" width="320" height="240" hidden></canvas>
</div>

<div class="card" style="margin-top:12px;">
  <div class="row">
    <label>訊號視覺化</label>
  </div>
  <canvas id="scope" width="900" height="180"></canvas>
</div>

<div class="card" style="margin-top:12px;">
  <div class="row" style="flex:1;">
    <div style="flex:1;min-width:260px">
      <div><b>Preamble：</b> <span class="mono" id="preambleView">01010101</span></div>
      <div><b>Payload bits：</b> <span class="mono" id="payloadBitsView">8</span></div>
      <div><b>位元串：</b> <span id="bits" class="mono"></span></div>
      <div><b>十六進位：</b> <span id="hex" class="mono"></span></div>
      <div><b>ASCII：</b> <span id="ascii" class="mono"></span></div>
      <div><b>診斷：</b> <span id="diag" class="mono"></span></div>
    </div>
  </div>
</div>

<script>
// ====== 參數（這裡設定 2 Hz / 8-bit）======
const PREAMBLE_BITS = '01010101';
const PAYLOAD_BITS  = 8;           // ✅ 僅解析 8 bit
// ==========================================

const els = {
  camera: document.getElementById('camera'),
  start: document.getElementById('start'),
  stop: document.getElementById('stop'),
  video: document.getElementById('video'),
  overlay: document.getElementById('overlay'),
  canvas: document.getElementById('canvas'),
  scope: document.getElementById('scope'),
  symRate: document.getElementById('symRate'),
  autoRate: document.getElementById('autoRate'),
  bits: document.getElementById('bits'),
  hex: document.getElementById('hex'),
  ascii: document.getElementById('ascii'),
  diag: document.getElementById('diag'),
  preambleView: document.getElementById('preambleView'),
  payloadBitsView: document.getElementById('payloadBitsView')
};
els.preambleView.textContent = PREAMBLE_BITS;
els.payloadBitsView.textContent = PAYLOAD_BITS.toString();

let stream = null;
let running = false;
let roi = null; // {x,y,w,h} normalized (0~1)
let ctxScope = els.scope.getContext('2d');

async function listCams() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const vids = devices.filter(d => d.kind === 'videoinput');
  els.camera.innerHTML = '';
  vids.forEach((v,i) => {
    const opt = document.createElement('option');
    opt.value = v.deviceId;
    opt.textContent = v.label || `Camera ${i+1}`;
    els.camera.appendChild(opt);
  });
}

async function startCam() {
  if (!navigator.mediaDevices?.getUserMedia) {
    alert('此瀏覽器不支援 getUserMedia。請用 Chrome / Edge / Safari，並確保 HTTPS。');
    return;
  }
  const deviceId = els.camera.value || undefined;
  const constraints = {
    audio: false,
    video: {
      facingMode: 'environment',
      width: { ideal: 1280 },
      height: { ideal: 720 },
      frameRate: { ideal: 60, max: 60 },
      ...(deviceId ? { deviceId: { exact: deviceId } } : {})
    }
  };
  stream = await navigator.mediaDevices.getUserMedia(constraints);
  els.video.srcObject = stream;
  await els.video.play();
  fitOverlay();
  running = true;
  els.start.disabled = true;
  els.stop.disabled = false;
  processLoop();
}

function stopCam() {
  running = false;
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
  els.start.disabled = false;
  els.stop.disabled = true;
}

function fitOverlay() {
  const rect = els.video.getBoundingClientRect();
  els.overlay.width = rect.width;
  els.overlay.height = rect.height;
  drawOverlay();
}
window.addEventListener('resize', fitOverlay);

function drawOverlay() {
  const octx = els.overlay.getContext('2d');
  octx.clearRect(0,0,els.overlay.width,els.overlay.height);
  if (roi) {
    const rx = roi.x * els.overlay.width;
    const ry = roi.y * els.overlay.height;
    const rw = roi.w * els.overlay.width;
    const rh = roi.h * els.overlay.height;
    octx.strokeStyle = '#22c55e';
    octx.lineWidth = 2;
    octx.strokeRect(rx, ry, rw, rh);
  } else {
    octx.fillStyle = 'rgba(0,0,0,.5)';
    octx.fillRect(8,8,210,26);
    octx.fillStyle = 'white';
    octx.font = '14px system-ui, sans-serif';
    octx.fillText('在影片上拖拉以選取 ROI', 16, 26);
  }
}
// 讓使用者在影片上拉 ROI
(function enableRoiDrag() {
  let dragging = false, sx=0, sy=0;
  els.overlay.style.pointerEvents = 'auto';
  els.overlay.addEventListener('mousedown', (e)=>{
    const r = els.overlay.getBoundingClientRect();
    dragging = true;
    sx = (e.clientX - r.left); sy = (e.clientY - r.top);
  });
  window.addEventListener('mousemove', (e)=>{
    if(!dragging) return;
    const r = els.overlay.getBoundingClientRect();
    const cx = Math.min(Math.max(e.clientX - r.left, 0), r.width);
    const cy = Math.min(Math.max(e.clientY - r.top, 0), r.height);
    const x = Math.min(sx, cx), y = Math.min(sy, cy);
    const w = Math.abs(cx - sx), h = Math.abs(cy - sy);
    roi = { x: x/r.width, y: y/r.height, w: Math.max(8/r.width, w/r.width), h: Math.max(8/r.height, h/r.height) };
    drawOverlay();
  });
  window.addEventListener('mouseup', ()=> dragging=false);
})();

// ====== 訊號擷取與解碼 ======
const buf = { t: [], y: [], maxSec: 6.0 };

function pushSample(t, y) {
  buf.t.push(t); buf.y.push(y);
  while (buf.t.length && (t - buf.t[0] > buf.maxSec)) {
    buf.t.shift(); buf.y.shift();
  }
}

function avgLumaFromROI(video) {
  const w = 96, h = 54;
  const c = els.canvas;
  c.width = w; c.height = h;
  const ctx = c.getContext('2d', { willReadFrequently: true });
  const vw = video.videoWidth, vh = video.videoHeight;
  let sx=0, sy=0, sw=vw, sh=vh;
  if (roi) {
    sx = Math.round(roi.x * vw);
    sy = Math.round(roi.y * vh);
    sw = Math.max(8, Math.round(roi.w * vw));
    sh = Math.max(8, Math.round(roi.h * vh));
  }
  ctx.drawImage(video, sx, sy, sw, sh, 0, 0, w, h);
  const img = ctx.getImageData(0,0,w,h).data;
  let acc = 0;
  for (let i=0;i<img.length;i+=4) {
    acc += 0.2126*img[i] + 0.7152*img[i+1] + 0.0722*img[i+2];
  }
  return acc / (w*h*255);
}

// 高通 + 自適應門檻
function preprocess(yArr, tArr) {
  if (yArr.length < 5) return { z: [], thrHi: 0.2, thrLo: -0.2 };
  const alpha = 0.1;
  let ema = yArr[0], z = new Array(yArr.length);
  for (let i=0;i<yArr.length;i++){
    ema = alpha*yArr[i] + (1-alpha)*ema;
    z[i] = yArr[i] - ema;
  }
  let maxAbs = 1e-9;
  for (const v of z) maxAbs = Math.max(maxAbs, Math.abs(v));
  z = z.map(v => v/maxAbs);
  const N = Math.min( Math.floor(1.5*avgFps(tArr)), z.length );
  const recent = z.slice(-N);
  const sorted = [...recent].sort((a,b)=>a-b);
  const hi = sorted[Math.floor(sorted.length*0.7)] || 0.2;
  const lo = sorted[Math.floor(sorted.length*0.3)] || -0.2;
  return { z, thrHi: hi, thrLo: lo };
}

function avgFps(tArr) {
  if (tArr.length<2) return 30;
  const n = Math.min(90, tArr.length-1);
  let acc=0;
  for (let i=tArr.length-n;i<tArr.length-1;i++){
    acc += (tArr[i+1]-tArr[i]);
  }
  const dt = acc/Math.max(1,n-1);
  return dt>0 ? 1/dt : 30;
}

function detectEdges(z, t, hi, lo) {
  let state = 0;
  const edges = [];
  for (let i=1;i<z.length;i++){
    const v = z[i], pv=z[i-1];
    if (state>=0 && v<=lo && pv>lo){ state=-1; edges.push({t:t[i], dir:-1}); }
    if (state<=0 && v>=hi && pv<hi){ state=+1; edges.push({t:t[i], dir:+1}); }
  }
  return edges;
}

function estimateSymbolPeriod(edges) {
  if (edges.length<8) return null;
  const intervals = [];
  for (let i=1;i<edges.length;i++) intervals.push(edges[i].t - edges[i-1].t);
  intervals.sort((a,b)=>a-b);
  const core = intervals.slice(Math.floor(intervals.length*0.1), Math.ceil(intervals.length*0.9));
  if (!core.length) return null;
  const median = core[Math.floor(core.length/2)];
  return median*2; // T_half*2 ≈ T_bit
}

function decodeManchester(z, t, Tbit, preambleBits = '01010101', payloadBits = 8) {
  if (!Tbit || t.length<3) return null;
  const t0 = t[0];
  const nBits = preambleBits.length + payloadBits;

  const sampleAt = (ts)=>{
    const i = binarySearchTime(t, ts);
    if (i<0 || i>=t.length-1) return 0;
    const a = (ts - t[i])/(t[i+1]-t[i] || 1e-6);
    return z[i]*(1-a)+z[i+1]*a;
  };

  const midDiff = [];
  for (let k=0;k<nBits;k++){
    const tL = t0 + (k+0.25)*Tbit;
    const tR = t0 + (k+0.75)*Tbit;
    midDiff.push(Math.sign(sampleAt(tR) - sampleAt(tL))); // +1: 低->高(1)，-1: 高->低(0)
  }
  const tryPolarity = (sign)=> midDiff.map(v => (v*sign>0? '1':'0')).join('');

  const b1 = tryPolarity(+1);
  const b2 = tryPolarity(-1);
  const checkAndSplit = (bitsStr)=>{
    if (bitsStr.startsWith(preambleBits)) {
      const payload = bitsStr.slice(preambleBits.length, preambleBits.length+payloadBits);
      return { ok:true, bits: bitsStr, payload };
    }
    return { ok:false };
  };
  const c1 = checkAndSplit(b1); if (c1.ok) return c1;
  const c2 = checkAndSplit(b2); if (c2.ok) return c2;
  return null;
}

function binarySearchTime(t, target){
  let lo=0, hi=t.length-1;
  if (target<=t[0]) return 0;
  if (target>=t[hi]) return hi-1;
  while (lo<=hi){
    const mid=(lo+hi)>>1;
    if (t[mid]===target) return Math.max(0, mid-1);
    if (t[mid]<target) lo=mid+1; else hi=mid-1;
  }
  return Math.max(0, lo-1);
}

function bitsToHex(bits) {
  const out=[];
  for (let i=0;i<bits.length;i+=8){
    const b = bits.slice(i,i+8);
    if (b.length<8) break;
    out.push(parseInt(b,2).toString(16).padStart(2,'0').toUpperCase());
  }
  return out.join(' ');
}
function bitsToAscii(bits){
  let s='';
  for (let i=0;i<bits.length;i+=8){
    const b=bits.slice(i,i+8);
    if (b.length<8) break;
    const code=parseInt(b,2);
    s += (code>=32 && code<=126)? String.fromCharCode(code) : '·';
  }
  return s;
}

// let ctxScope = els.scope.getContext('2d');
function drawScope(t, z, hi, lo){
  const w = els.scope.width, h = els.scope.height;
  ctxScope.clearRect(0,0,w,h);
  ctxScope.strokeStyle = '#e5e7eb';
  ctxScope.beginPath(); ctxScope.moveTo(0, h/2); ctxScope.lineTo(w, h/2); ctxScope.stroke();
  if (t.length<2) return;
  const tmin = t[0], tmax = t[t.length-1];
  const sx = x => ( (x - tmin) / (tmax - tmin) ) * w;
  const sy = y => h*0.5 - y*(h*0.45);
  ctxScope.beginPath();
  for (let i=0;i<z.length;i++){
    const x = sx(t[i]), y = sy(z[i]);
    if (i===0) ctxScope.moveTo(x,y); else ctxScope.lineTo(x,y);
  }
  ctxScope.strokeStyle = '#111827';
  ctxScope.lineWidth = 1.25; ctxScope.stroke();
  ctxScope.strokeStyle = '#9ca3af';
  ctxScope.setLineDash([6,4]);
  ctxScope.beginPath(); ctxScope.moveTo(0, sy(hi)); ctxScope.lineTo(w, sy(hi)); ctxScope.stroke();
  ctxScope.beginPath(); ctxScope.moveTo(0, sy(lo)); ctxScope.lineTo(w, sy(lo)); ctxScope.stroke();
  ctxScope.setLineDash([]);
}

async function processLoop(){
  const startTime = performance.now();
  const useRVFC = 'requestVideoFrameCallback' in HTMLVideoElement.prototype;

  const tick = (_now, metadata) => {
    if (!running) return;
    const tSec = metadata?.mediaTime ?? ((performance.now() - startTime)/1000);
    const y = avgLumaFromROI(els.video);
    pushSample(tSec, y);

    const { z, thrHi, thrLo } = preprocess(buf.y, buf.t);
    drawScope(buf.t.slice(-z.length), z, thrHi, thrLo);

    // Tbit
    let Tbit = null;
    if (els.autoRate.checked) {
      const edges = detectEdges(z, buf.t.slice(-z.length), thrHi, thrLo);
      Tbit = estimateSymbolPeriod(edges);
    } else {
      const R = parseFloat(els.symRate.value)||2;
      Tbit = 1.0 / R;
    }

    // 取足夠長度的尾端視窗（依 preamble+payload 自動計算）
    let result = null;
    if (Tbit && z.length>24) {
      const needSec = (PREAMBLE_BITS.length + PAYLOAD_BITS) * Tbit + 0.5; // ✅ 不再寫死 64
      const t = buf.t, yz = z;
      let i0 = t.length-1;
      while (i0>0 && (t[t.length-1] - t[i0]) < needSec) i0--;
      const tz = t.slice(i0), zz = yz.slice(i0);
      result = decodeManchester(zz, tz, Tbit, PREAMBLE_BITS, PAYLOAD_BITS); // ✅ 僅解析 8 bit
    }

    if (result) {
      els.bits.textContent  = result.payload;
      els.hex.textContent   = bitsToHex(result.payload);
      els.ascii.textContent = bitsToAscii(result.payload);
      els.diag.textContent  = `Tbit≈${Tbit?.toFixed(3)}s, FPS≈${avgFps(buf.t).toFixed(1)}`;
    } else {
      els.diag.textContent  = `解碼中… Tbit≈${Tbit?Tbit.toFixed(3):'N/A'}s, FPS≈${avgFps(buf.t).toFixed(1)}`;
    }

    if (useRVFC) els.video.requestVideoFrameCallback(tick);
    else setTimeout(()=>tick(), 0);
  };

  if (useRVFC) els.video.requestVideoFrameCallback(tick);
  else (function polyfill(){ if(running){ tick(); requestAnimationFrame(polyfill);} })();
}

// 綁定 UI
els.start.addEventListener('click', startCam);
els.stop.addEventListener('click', stopCam);
navigator.mediaDevices?.enumerateDevices && listCams();
</script>
</body>
</html>
